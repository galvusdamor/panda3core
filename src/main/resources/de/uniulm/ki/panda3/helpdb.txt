% short documentation:
% behind $ list the possible input values; be careful to mention
% only one representative per set of equivalent keys. E.g., if a* and astar are
% equivalent, only list one of them behind $ -- the synonyms are only defined
% for the actual definition of the respective key.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
main
---- no text necessary
Available options for PANDA3:

To run PANDA3, you have to specify at least a domain and a problem file.
For most parameters, their order does not matter.
Parameters can be freely interleaved with the specification of a domain, problem, and output file.
\n
PANDA3's general call syntax is as follows:
    java -jar panda3.jar [OPTIONS] domfile.xyz [OPTIONS] probfile.xyz [OPTIONS] [outputfile.{pdf|dot}] [OPTIONS]
$ -help -noGeneralInfo -noDomainInfo -timelimit -planSearch -flaw -noSearch -search -heuristic -seed -parser -programPath -continueOnSolution






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-help
Explains how -help [OPTION or KEY] works.
Available options for -help:

Run "-help [OPTION or KEY]" to show help for the respective option or key.
$







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-parser
Select the parser for the input files.
Available parsers:

We support various different input formats for our planner. Default value is "auto", which should select the correct parser depending on the input file.
$ xml old-pddl pddl hpddl hddl auto





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
xml
Parser for our PANDA XML standard.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "xml" IS A KEY, NOT AN OPTION.

We do not posses a description of our XML-based input specification. We also do not provide support, since we will abandon that format in favor of hddl, a new input language HDDL that we are currently developing.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
hddl
Parser for our HDDL standard.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "hddl" IS A KEY, NOT AN OPTION.

HDDL is a novel input language for hierarchical planning problems that we are currently developing. It extends PDDL 2.1, language level 1 (at least most of its features), by language features for HTN and hybrid planning.

For questions regarding this standard, please contact Daniel Höller.
$


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
hpddl
Parser for the HPDDL standard.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "hpddl" IS A KEY, NOT AN OPTION.

HPDDL stands for hierarchical PDDL. It is a description for HTN planning problems, developed by Dr. Ron Alford. It is used, for instance, by the planner (that compiles HTN problems into a sequence of PDDL problems) that is described in the following paper:

@InProceedings{Alford16BoundToPlan,
  Title                    = {Bound to Plan: Exploiting Classical Heuristics via Automatic Translations of Tail-Recursive HTN Problems},
  Author                   = {Alford, Ron and Behnke, Gregor and H{\"o}ller, Daniel and Bercher, Pascal and Biundo, Susanne and Aha, David},
  Booktitle                = {Proceedings of the 26th International Conference on Automated Planning and Scheduling ({ICAPS} 2016)},
  Year                     = {2016},
  Pages                    = {20--28},
  Publisher                = {{AAAI} Press}
}

Note, however, that this description language is not part of the paper. The planner that is uses is, however, openly available on http://github.com/ronwalf/HTN-Translation
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pddl
Parser for the PDDL standard.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "pddl" IS A KEY, NOT AN OPTION.

This is the parser for the well-known PDDL standard.
$








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
old-pddl
Parser for PDDL without types.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "old-pddl" IS A KEY, NOT AN OPTION.

The parser for old-pddl is a PDDL parser that can read the older PDDL standard in which there are no types.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
auto
Automatic parser selection.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "auto" IS A KEY, NOT AN OPTION.

This option chooses the parser automatically depending on the input file. If this works correctly, no other parser needs to be selected.
$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-noGeneralInfo
Suppress additional information during planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-noGeneralInfo" IS A SWITCH, NOT AN OPTION.

By default, the planner will show -- during planning -- what they are currently doing, such as constructing the planning graph, etc.

When using this command, the planner will suppress this information during planning.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-continueOnSolution
Don't stop planning after a solution has been found.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-continueOnSolution" IS A SWITCH, NOT AN OPTION.

By default, the standard PANDA3 planner will stop after some solution has been generated. Using this option will cause the planner to continue search and finding additional solutions until the time or space limit is exceeded.

This feature has never been tested sufficiently and is very likely buggy. That is, please do not use it for scientific comparisons.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-noDomainInfo
Suppressed information about the domain.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-printAdditionalInfo" IS A SWITCH, NOT AN OPTION.

By default, the planner gives statistical information about the domain, for example the number of tasks, primitive tasks, abstract tasks, decomposition methods, predicates, sorts, and constants. Using this option supresses this information.

Please note that this information is shown several times: Many of our heuristics base upon very basic language features, that is: a ground model in which primitive tasks have only positive preconditions. Also our decomposition methods do not have preconditions (as opposed to the SHOP2 model) or effects (yes, some hierarchical planning formalisms even allow effects of methods). We compile all these higher-level language features away and after each compilation step the domain information is printed (if not supressed).
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-planSearch
Uses the "traditional" PANDA3, decompositional-based.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-planSearch" IS A SWITCH, NOT AN OPTION.

PANDA3 is more than just "one planning system". Apart from additional capabilities like repairing and explaining plans (not yet provided online), or validating plans, we also have three differently working planners (only two of which are provided online at the moment). While these planners share the same preprocessing, e.g., grounding, they are completely different in the way they solve problems.
\n
This planner configuration uses the "traditional" PANDA3, which performs search in the space of partial plans. We refer to its search procedure as hybrid planning, because it fuses hierarchical planning with partial order causal link (POCL) planning. The algorithm is a standard flaw-based POCL algorithm that can additionally cope with abstract tasks. It is explained in the following paper:
\n
Hybrid Planning Heuristics Based on Task Decomposition Graphs
by Pascal Bercher and Shawn Keen and Susanne Biundo
published in SoCS 2014 by AAAI Press.
\n
Please note that this plan space-based planning algorithm requires a search algorithm (like BFS or A*) and a flaw selection function.
\n
We further want to note that this planner is able of solving a broad variety of problem classes, including HTN problems, TIHTN problems (HTN problems with task insertion), hybrid problems with or without task insertion (these problems extend HTN/TIHTN problems via preconditions and effects of abstract tasks and by causal links in the domain model's partial plans), classical problems, and POCL problems (which are like classical problems, but with an initial primitive partial plan). Please note that the property whether task insertion is allowed cannot be passed on to the planner as an option, but it needs to be specified in the domain or problem file, since this is not an algorithmic choice, but a property of the problem (class) that is solved.
$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-noSearch
Terminate after the preprocessing.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-noSearch" IS A SWITCH, NOT AN OPTION.

This option is mainly for debugging purposes: choosing it will cause the planner to terminate as soon as it finished all preprocessing steps, i.e., right before it would initiate the search.
$








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-search
Choose the search strategy.
Available search strategies:

Using "--search [KEY]" allows to select the search strategy given plan-based search ("traditional PANDA3") was selected.
$ bfs dfs greedy uniform-cost a* depth-a*





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
bfs
Breadth-first Search.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "bfs" IS A KEY, NOT AN OPTION.

This is the standard breadth-first search strategy as described in the text books using a queue.
$



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dfs
Depth-first Search.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "dfs" IS A KEY, NOT AN OPTION.

This is the standard depth-first search strategy as described in the text books using a stack.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
greedy
Greedy Search.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "greedy" IS A KEY, NOT AN OPTION.

This is standard greedy search, i.e., you must also define a heuristic.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dijkstra uniform-cost
Uniform cost search.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "dijkstra" IS A KEY, NOT AN OPTION.

This is standard dijkstra algorithm, that is, standard uniform-cost search. Thus, action costs are ignored and assumed being equal to one instead.
$







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
astar a*
A*, f(n)=w*g(n)+h(n), w weight, g cost, h heuristic
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "a*" IS A KEY, NOT AN OPTION.

This is weighted A*, i.e., search nodes n are selected according to their value f(n)=w*g(n)+h(n), where w is a weight, g(n) is the node's action cost and h(n) is its heuristic value. Please note that our planners currently do not support action costs, i.e., we assume cost 1 for each primitive action.
\n
If you just select this heuristic, standard A* search is performed. For weighted A*, add the weight in parentheses, e.g., astar(2).

$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
depth-astar depth-a*
A*, f(n)=d(n)+h(n), w weight, d depth, h heuristic
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "depth-astar" IS A KEY, NOT AN OPTION.
% Auch astar-depth und a*-depth wäre möglich, aber

This is weighted A*, i.e., search nodes n are selected according to their value f(n)=w*d(n)+h(n), but d(n) is the depth in the search tree rather than the cost of the current search node as usual; w is the weight and h(n) is its heuristic value.
\n
If you just select this heuristic, standard depth-A* search is performed. For weighted depth-A*, add the weight in parentheses, e.g., depth-astar(2).
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-flaw -f
Choose a flaw selection strategy.
Available flaw selection strategies:

Using "-flaw [KEYS]" allows to select a flaw selection strategy for the plan space-based search algorithm. Please note that you can select a sequence of flaw selection strategies for tie-breaking. To give a sequence, use a comma-separated list of flaw selection functions without white spaces.
$ lcfr random-flaw





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
lcfr
Least-Cost Flaw-Repair.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "lcfr" IS A KEY, NOT AN OPTION.

The flaw selection strategy lcfr, Least-Cost Flaw-Repair, was introduced in the following paper:
\n
Least-Cost Flaw Repair: A Plan Refinement Strategy for Partial-Order Planning
by David Joslin and Martha E. Pollack
published in AAAI 1994 by AAAI Press.
\n
That strategy is both extremely simple and efficient: it always selects a flaw for which there are the least number of "repairs", i.e., plan modifications. That way, the branching factor of the explored search space is locally minimized, which shows empirically good results on average.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
random-flaw
Selects a random flaw.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "random-flaw" IS A KEY, NOT AN OPTION.

This flaw selection function for the plan space-based PANDA3 algorithm selects a random flaw. It is initialized with the default random seed.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-heuristic -h
Choose one of many heuristics.
Available heuristics:

Using "-heuristic [KEY]" allows to select one of many heuristics that is used for the plan selection function. Please note that most of the heuristics are developed for the plan space-based search algorithm, but some of them also (or exclusively) work for the progression-based planner. We will be clear about this in the respective heuristics. Most heuristics have additional arguments, which can be passed on using the following syntax:
    -heuristic HEURISTIC_NAME(PARAM1=VALUE1,PARAM2=VALUE2)
$ random-heuristic #flaw #oc #ps #abstract add add-r relax tdg-m tdg-m-r tdg-m-lifted tdg-c tdg-c-r tdg-c-lifted










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
random-heuristic
Returns random integers.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "random-heuristic" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm returns a random integer. It is initialized with the default random seed.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tdg-m-lifted
TDG-m for lifted planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "tdg-m-lifted" IS A KEY, NOT AN OPTION.

This is a heuristic for the plan space-based PANDA3 algorithm. It is the lifted variant of the TDG-m heuristic (i.e., it gives admissible estimates of the number of modifications requiried to turn a current plan into a solution).

This variant does not perform recomputation and it is suited for lifted planning, where the plan steps in search nodes may still contain variables. For this, given a plan step, it first builds all groundings for this step and retrieves all corresponding heuristic values from the TDG, of which it retrieves the minimum.

Since this heuristic is based upon the TDG and this TDG in turn depends on the planning graph (PG), options concerning the PG also influence this heuristic. We use our *default PG* for the heuristic, which does not use mutexes. However, if you change this default (by specifying which PG is used via the option "-groundedReachability"), then this improved PG is used for the heuristic.

The heuristic is described in the following paper:

@InProceedings{Bercher17AdmissibleHTNHeuristic,
  Title                    = {An Admissible HTN Planning Heuristic},
  Author                   = {Pascal Bercher and Gregor Behnke and Daniel H\"oller and Susanne Biundo},
  Booktitle                = {Proceedings of the 26th International Joint Conference on Artificial Intelligence ({IJCAI} 2017)},
  Year                     = {2017},
  Pages                    = {480--488},
  Publisher                = {AAAI Press},
  Abstract                 = {Hierarchical task network (HTN) planning is well-known for being an efficient planning approach. This is mainly due to the success of the HTN planning system SHOP2. However, its performance depends on hand-designed search control knowledge. At the time being, there are only very few domain-independent heuristics, which are designed for differing hierarchical planning formalisms. Here, we propose an admissible heuristic for standard HTN planning, which allows to find optimal solutions heuristically. It bases upon the so-called task decomposition graph (TDG), a data structure reflecting reachable parts of the task hierarchy. We show (both in theory and empirically) that rebuilding it during planning can improve heuristic accuracy thereby decreasing the explored search space. The evaluation further studies the heuristic both in terms of plan quality and coverage.},
  Doi                      = {10.24963/ijcai.2017/68},
  File                     = {see Bercher's website, www.uni-ulm.de/in/ki/bercher/},
}

Please note that the empirical evaluation in the paper did not evaluate this lifted variant.

Also if you want to use PANDA3 for scientific comparisons (to be published), then please be aware that there are further system options that can have a tremendous impact on its performance (such as the underlying PG, as noted above). To reproduce the results of our IJCAI 2017 paper, we have provided pre-defined system configurations that you can use for this purpose (see "-systemConfig").
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tdg-c-lifted
TDG-c for lifted planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "tdg-c-lifted" IS A KEY, NOT AN OPTION.

This is a heuristic for the plan space-based PANDA3 algorithm. It is the lifted variant of the TDG-c heuristic (i.e., it gives admissible estimates of the action costs* of the missing primitive actions to be inserted into a current plan in order to turn it into a solution).

*Please note that at the moment, our planner does not yet have the capability to cope with action costs. For this reason, this heuristic assumes unit costs, i.e., it currently estimates the number of actions that have to be inserted.

This variant does not perform recomputation and it is suited for lifted planning, where the plan steps in search nodes may still contain variables. For this, given a plan step, it first builds all groundings for this step and retrieves all corresponding heuristic values from the task decomposition graph (TDG), of which it retrieves the minimum.

Since this heuristic is based upon the TDG and this TDG in turn depends on the planning graph (PG), options concerning the PG also influence this heuristic. We use our *default PG* for the heuristic, which does not use mutexes. However, if you change this default (by specifying which PG is used via the option "-groundedReachability"), then this improved PG is used for the heuristic.

The heuristic is described in the following paper:

@InProceedings{Bercher17AdmissibleHTNHeuristic,
  Title                    = {An Admissible HTN Planning Heuristic},
  Author                   = {Pascal Bercher and Gregor Behnke and Daniel H\"oller and Susanne Biundo},
  Booktitle                = {Proceedings of the 26th International Joint Conference on Artificial Intelligence ({IJCAI} 2017)},
  Year                     = {2017},
  Pages                    = {480--488},
  Publisher                = {AAAI Press},
  Abstract                 = {Hierarchical task network (HTN) planning is well-known for being an efficient planning approach. This is mainly due to the success of the HTN planning system SHOP2. However, its performance depends on hand-designed search control knowledge. At the time being, there are only very few domain-independent heuristics, which are designed for differing hierarchical planning formalisms. Here, we propose an admissible heuristic for standard HTN planning, which allows to find optimal solutions heuristically. It bases upon the so-called task decomposition graph (TDG), a data structure reflecting reachable parts of the task hierarchy. We show (both in theory and empirically) that rebuilding it during planning can improve heuristic accuracy thereby decreasing the explored search space. The evaluation further studies the heuristic both in terms of plan quality and coverage.},
  Doi                      = {10.24963/ijcai.2017/68},
  File                     = {see Bercher's website, www.uni-ulm.de/in/ki/bercher/},
}

Please note that the empirical evaluation in the paper did not evaluate this lifted variant.

Also if you want to use PANDA3 for scientific comparisons (to be published), then please be aware that there are further system options that can have a tremendous impact on its performance (such as the underlying PG, as noted above). To reproduce the results of our IJCAI 2017 paper, we have provided pre-defined system configurations that you can use for this purpose (see "-systemConfig").
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tdg-m tdg-m-ground
TDG-m for ground planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "tdg-m" IS A KEY, NOT AN OPTION.

This is a heuristic for the plan space-based PANDA3 algorithm. It is the standard variant of the TDG-m heuristic (i.e., it gives admissible estimates of the number of modifications requiried to turn a current plan into a solution).

This standard variant does *not* perform any recomputation of the underlying task decompostion graph (TDG) and it is suited for ground planning, where all plan steps in all search nodes are always ground.

Since this heuristic is based upon the TDG and this TDG in turn depends on the planning graph (PG), options concerning the PG also influence this heuristic. We use our *default PG* for the heuristic, which does not use mutexes. However, if you change this default (by specifying which PG is used via the option "-groundedReachability"), then this improved PG is used for the heuristic.

The heuristic is described in the following paper:

@InProceedings{Bercher17AdmissibleHTNHeuristic,
  Title                    = {An Admissible HTN Planning Heuristic},
  Author                   = {Pascal Bercher and Gregor Behnke and Daniel H\"oller and Susanne Biundo},
  Booktitle                = {Proceedings of the 26th International Joint Conference on Artificial Intelligence ({IJCAI} 2017)},
  Year                     = {2017},
  Pages                    = {480--488},
  Publisher                = {AAAI Press},
  Abstract                 = {Hierarchical task network (HTN) planning is well-known for being an efficient planning approach. This is mainly due to the success of the HTN planning system SHOP2. However, its performance depends on hand-designed search control knowledge. At the time being, there are only very few domain-independent heuristics, which are designed for differing hierarchical planning formalisms. Here, we propose an admissible heuristic for standard HTN planning, which allows to find optimal solutions heuristically. It bases upon the so-called task decomposition graph (TDG), a data structure reflecting reachable parts of the task hierarchy. We show (both in theory and empirically) that rebuilding it during planning can improve heuristic accuracy thereby decreasing the explored search space. The evaluation further studies the heuristic both in terms of plan quality and coverage.},
  Doi                      = {10.24963/ijcai.2017/68},
  File                     = {see Bercher's website, www.uni-ulm.de/in/ki/bercher/},
}

This is one of the heuristics that we evaluated in the paper.

However, if you want to use PANDA3 for scientific comparisons (to be published), then please be aware that there are further system options that can have a tremendous impact on its performance (such as the underlying PG, as noted above). To reproduce the results of our IJCAI 2017 paper, we have provided pre-defined system configurations that you can use for this purpose (see "-systemConfig").
$



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tdg-m-r tdg-m-ground-recompute
TDG-m for ground planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "tdg-m-r" IS A KEY, NOT AN OPTION.

This is a heuristic for the plan space-based PANDA3 algorithm. It is the recomputation variant of the TDG-c heuristic (i.e., it gives admissible estimates of the number of modifications requiried to turn a current plan into a solution), but it recomputes the underlying TDG after certain plan modifications.

This variant is suited for ground planning, where all plan steps in all search nodes are always ground. In addition, it recomputes the underlying task decomposition graph (TDG) after a plan modification has been performed that could change this TDG, e.g. after each task decomposition (in case there have been more than one method available for it), for details, we refer to the paper (seel below).

Since this heuristic is based upon the TDG and this TDG in turn depends on the planning graph (PG), options concerning the PG also influence this heuristic. We use our *default PG* for the heuristic, which does not use mutexes. However, if you change this default (by specifying which PG is used via the option "-groundedReachability"), then this improved PG is used for the heuristic.

The heuristic is described in the following paper:

@InProceedings{Bercher17AdmissibleHTNHeuristic,
  Title                    = {An Admissible HTN Planning Heuristic},
  Author                   = {Pascal Bercher and Gregor Behnke and Daniel H\"oller and Susanne Biundo},
  Booktitle                = {Proceedings of the 26th International Joint Conference on Artificial Intelligence ({IJCAI} 2017)},
  Year                     = {2017},
  Pages                    = {480--488},
  Publisher                = {AAAI Press},
  Abstract                 = {Hierarchical task network (HTN) planning is well-known for being an efficient planning approach. This is mainly due to the success of the HTN planning system SHOP2. However, its performance depends on hand-designed search control knowledge. At the time being, there are only very few domain-independent heuristics, which are designed for differing hierarchical planning formalisms. Here, we propose an admissible heuristic for standard HTN planning, which allows to find optimal solutions heuristically. It bases upon the so-called task decomposition graph (TDG), a data structure reflecting reachable parts of the task hierarchy. We show (both in theory and empirically) that rebuilding it during planning can improve heuristic accuracy thereby decreasing the explored search space. The evaluation further studies the heuristic both in terms of plan quality and coverage.},
  Doi                      = {10.24963/ijcai.2017/68},
  File                     = {see Bercher's website, www.uni-ulm.de/in/ki/bercher/},
}

This is one of the heuristics that we evaluated in the paper.

However, if you want to use PANDA3 for scientific comparisons (to be published), then please be aware that there are further system options that can have a tremendous impact on its performance (such as the underlying PG, as noted above). To reproduce the results of our IJCAI 2017 paper, we have provided pre-defined system configurations that you can use for this purpose (see "-systemConfig").
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tdg-c tdg-c-ground
TDG-c for ground planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "tdg-c" IS A KEY, NOT AN OPTION.

This is a heuristic for the plan space-based PANDA3 algorithm. It is the standard variant of the TDG-c heuristic (i.e., it gives admissible estimates of the action costs* of the missing primitive actions to be inserted into a current plan in order to turn it into a solution).

*Please note that at the moment, our planner does not yet have the capability to cope with action costs. For this reason, this heuristic assumes unit costs, i.e., it currently estimates the number of actions that have to be inserted.

This standard variant does *not* perform any recomputation of the underlying task decompostion graph (TDG) and it is suited for ground planning, where all plan steps in all search nodes are always ground.

Since this heuristic is based upon the TDG and this TDG in turn depends on the planning graph (PG), options concerning the PG also influence this heuristic. We use our *default PG* for the heuristic, which does not use mutexes. However, if you change this default (by specifying which PG is used via the option "-groundedReachability"), then this improved PG is used for the heuristic.

The heuristic is described in the following paper:

@InProceedings{Bercher17AdmissibleHTNHeuristic,
  Title                    = {An Admissible HTN Planning Heuristic},
  Author                   = {Pascal Bercher and Gregor Behnke and Daniel H\"oller and Susanne Biundo},
  Booktitle                = {Proceedings of the 26th International Joint Conference on Artificial Intelligence ({IJCAI} 2017)},
  Year                     = {2017},
  Pages                    = {480--488},
  Publisher                = {AAAI Press},
  Abstract                 = {Hierarchical task network (HTN) planning is well-known for being an efficient planning approach. This is mainly due to the success of the HTN planning system SHOP2. However, its performance depends on hand-designed search control knowledge. At the time being, there are only very few domain-independent heuristics, which are designed for differing hierarchical planning formalisms. Here, we propose an admissible heuristic for standard HTN planning, which allows to find optimal solutions heuristically. It bases upon the so-called task decomposition graph (TDG), a data structure reflecting reachable parts of the task hierarchy. We show (both in theory and empirically) that rebuilding it during planning can improve heuristic accuracy thereby decreasing the explored search space. The evaluation further studies the heuristic both in terms of plan quality and coverage.},
  Doi                      = {10.24963/ijcai.2017/68},
  File                     = {see Bercher's website, www.uni-ulm.de/in/ki/bercher/},
}

This is one of the heuristics that we evaluated in the paper.

However, if you want to use PANDA3 for scientific comparisons (to be published), then please be aware that there are further system options that can have a tremendous impact on its performance (such as the underlying PG, as noted above). To reproduce the results of our IJCAI 2017 paper, we have provided pre-defined system configurations that you can use for this purpose (see "-systemConfig").
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tdg-c-r tdg-c-ground-recompute
TDG-c for ground planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "tdg-c-r" IS A KEY, NOT AN OPTION.

This is a heuristic for the plan space-based PANDA3 algorithm. It is the recomputation variant of the TDG-c heuristic (i.e., it gives admissible estimates of the action costs* of the missing primitive actions to be inserted into a current plan in order to turn it into a solution), but it recomputes the underlying TDG after certain plan modifications.

*Please note that at the moment, our planner does not yet have the capability to cope with action costs. For this reason, this heuristic assumes unit costs, i.e., it currently estimates the number of actions that have to be inserted.

This variant is suited for ground planning, where all plan steps in all search nodes are always ground. In addition, it recomputes the underlying task decomposition graph (TDG) after a plan modification has been performed that could change this TDG, e.g. after each task decomposition (in case there have been more than one method available for it), for details, we refer to the paper (seel below).

Since this heuristic is based upon the TDG and this TDG in turn depends on the planning graph (PG), options concerning the PG also influence this heuristic. We use our *default PG* for the heuristic, which does not use mutexes. However, if you change this default (by specifying which PG is used via the option "-groundedReachability"), then this improved PG is used for the heuristic.

The heuristic is described in the following paper:

@InProceedings{Bercher17AdmissibleHTNHeuristic,
  Title                    = {An Admissible HTN Planning Heuristic},
  Author                   = {Pascal Bercher and Gregor Behnke and Daniel H\"oller and Susanne Biundo},
  Booktitle                = {Proceedings of the 26th International Joint Conference on Artificial Intelligence ({IJCAI} 2017)},
  Year                     = {2017},
  Pages                    = {480--488},
  Publisher                = {AAAI Press},
  Abstract                 = {Hierarchical task network (HTN) planning is well-known for being an efficient planning approach. This is mainly due to the success of the HTN planning system SHOP2. However, its performance depends on hand-designed search control knowledge. At the time being, there are only very few domain-independent heuristics, which are designed for differing hierarchical planning formalisms. Here, we propose an admissible heuristic for standard HTN planning, which allows to find optimal solutions heuristically. It bases upon the so-called task decomposition graph (TDG), a data structure reflecting reachable parts of the task hierarchy. We show (both in theory and empirically) that rebuilding it during planning can improve heuristic accuracy thereby decreasing the explored search space. The evaluation further studies the heuristic both in terms of plan quality and coverage.},
  Doi                      = {10.24963/ijcai.2017/68},
  File                     = {see Bercher's website, www.uni-ulm.de/in/ki/bercher/},
}

This is one of the heuristics that we evaluated in the paper.

However, if you want to use PANDA3 for scientific comparisons (to be published), then please be aware that there are further system options that can have a tremendous impact on its performance (such as the underlying PG, as noted above). To reproduce the results of our IJCAI 2017 paper, we have provided pre-defined system configurations that you can use for this purpose (see "-systemConfig").
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#flaw number-of-flaws
Number of flaws.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "#flaw" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm returns the number of flaws of the respective plan.
\n
Please note that this heuristic only works for the plan space-based PANDA3 algorithm. It works both for ground and for lifted planning. It works for all problem classes that can be solved by PANDA3.
$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#oc number-of-open-preconditions
Number of open preconditions.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "#oc" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm returns the number of open preconditions.
\n
Please note that this heuristic only works for the plan space-based PANDA3 algorithm. It works both for ground and for lifted planning. It works for all problem classes that can be solved by PANDA3.
$







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#ps number-of-plan-steps
Number of plan steps.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "#ps" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm returns the number of plan steps in a partial plan (excluding the artificial start and end steps).
\n
Please note that this heuristic only works for the plan space-based PANDA3 algorithm. It works both for ground and for lifted planning. It works for all problem classes that can be solved by PANDA3.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#abstract number-of-abstract-plan-steps
Number of abstract plan steps.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "#abstract" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm returns the number of abstract plan steps in a partial plan.
\n
Please note that this heuristic only works for the plan space-based PANDA3 algorithm. It works both for ground and for lifted planning. It works for all hierarchical problem classes that can be solved by PANDA3 (for the non-hierarchical ones, it returns 0, of course).
$











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
add
This is the Add heuristic for POCL planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "add" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm is the Add heuristic for POCL planning as desribed in the following paper:
\n
VHPOP: Versatile heuristic partial order planner
by Hakan L. S. Younes and Reid G. Simmons
published in the Journal of Artificial Intelligence Research (JAIR), 2003.
\n
In a nutshell, this heuristic takes all open preconditions of the current partial plan (i.e., those that are not protected by a causal link) and uses them as goal state the achievement of which is estimated relying on the Add heuristic for classical planning (however, the underlying planning graph is calculated only once, because the "current state" is always the initial state).
\n
Please note that this heuristic can not only be applied to non-hierarchical problems, but to all that can be solved by PANDA3. In case of hierarchical problems, the heuristic either ignores abstract tasks (in case they do not have preconditions, as is the case of HTN and TIHTN problems) or they are "regarded primitive", i.e. their preconditions are used as well in case they have some specified (as is the case for hybrid problems).
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
add-r add-reusing add_r add_reusing
This is the Add heuristic for POCL planning reusing actions.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "add-r" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm is the Add heuristic for POCL planning reusing actions as desribed in the following paper:
\n
VHPOP: Versatile heuristic partial order planner
by Hakan L. S. Younes and Reid G. Simmons
published in the Journal of Artificial Intelligence Research (JAIR), 2003.
\n
In a nutshell, this heuristic takes *some* of the open preconditions of the current partial plan (i.e., a subset of those that are not protected by a causal link) and uses them as goal state the achievement of which is estimated relying on the Add heuristic for classical planning (however, the underlying planning graph is calculated only once, because the "current state" is always the initial state). Instead of taking *all* unprotected preconditions (as the Add heuristic for POCL planning does), the Add-r heuristic only takes those open preconditions for which there is no action in the current partial plan that can, occording to the ordering and variable constraints, potentially be used as a supporter.
\n
As it is the case for the Add heuristic for POCL planning, this heuristic can not only be applied to non-hierarchical problems, but to all that can be solved by PANDA3. In case of hierarchical problems, the heuristic either ignores abstract tasks (in case they do not have preconditions, as is the case of HTN and TIHTN problems) or they are "regarded primitive", i.e. their preconditions are used as well in case they have some specified (as is the case for hybrid problems).
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
relax
This is the Relax heuristic for POCL planning.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "relax" IS A KEY, NOT AN OPTION.

This plan selection heuristic for the plan space-based PANDA3 algorithm is the Relax heuristic as desribed in the following paper:
\n
Reviving Partial Order Planning
by XuanLong Nguyen and Subbarao Kambhampati
published in IJCAI 2001 by Morgan Kaufmann
\n
In a nutshell, this heuristic takes all open preconditions of the current partial plan (i.e., those that are not protected by a causal link) and uses them as goal state the achievement of which is estimated relying on the FF heuristic for classical planning (however, the underlying (serial) planning graph is calculated only once, because the "current state" is always the initial state). The cost of the extracted relaxed plan is used as heuristic. However, actions in that relaxed plan that do also occur in the input partial plan do not contribute towards the heuristic.
\n
As it is the case for the Add and Add-r heuristic for POCL planning, this heuristic can not only be applied to non-hierarchical problems, but to all that can be solved by PANDA3. In case of hierarchical problems, the heuristic either ignores abstract tasks (in case they do not have preconditions, as is the case of HTN and TIHTN problems) or they are "regarded primitive", i.e. their preconditions are used as well in case they have some specified (as is the case for hybrid problems).
$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-timelimit
Sets the time limit in seconds.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-timelimit" TAKES AN INTEGER, NO OPTIONS.

Using "-timelimit [INT]" sets the time limit in seconds.
$





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-seed
Sets the initial random seed.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-seed" TAKES AN INTEGER, NO OPTIONS.

Using "-seed [INT]" sets the initial random seed to the specified integer. Otherwise, the pre-defined value 42 is used.
\n
Random seeds are used to systematically evaluate the impact of randomness in our systems. When ever some choice is made arbitrary (for instance, if search nodes are still invariant after breaking ties according to the given tie-breaking strategy), then this choice further depends on the random seed so that different runs can be made producing potentially different outcomes -- while still having deterministic behavior given the same random seed.
$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-programPath
For configuration of the SAT solvers.
THIS LINE DOES CURRENTLY NOT SHOW BECAUSE "-programPath" TAKES A STRING, NO OPTIONS.

Some of our programs, e.g. PANDA-totSAT (not yet delivered) or our plan verifyer (not yet delivered) base upon a SAT solver. Using this options allows to specify the solver that is used as well as the position where it can be found on the local machine. This is the syntax:

-programPath [SOLVER=PATH], where PATH is the solver file (inlcuding its absolute path) and SOLVER is the description of this solver, which is one of the following: minisat, cryptominisat, riss6, and mapleCOMSPS.
$